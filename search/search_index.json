{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyChebyshev","text":"<p>Fast multi-dimensional Chebyshev tensor interpolation with analytical derivatives.</p> <p>PyChebyshev builds a Chebyshev interpolant of any smooth function in up to N dimensions, then evaluates it and its derivatives in microseconds using vectorized NumPy operations.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Spectral accuracy \u2014 exponential error decay as node count increases</li> <li>Analytical derivatives \u2014 via spectral differentiation matrices (no finite differences)</li> <li>Fast evaluation \u2014 ~0.065 ms per query (price), ~0.29 ms for price + 5 Greeks</li> <li>Minimal storage \u2014 55 floats (440 bytes) for a 5D interpolant with 11 nodes per dimension</li> <li>Save &amp; load \u2014 persist built interpolants to disk; rebuild-free deployment</li> <li>Pure Python \u2014 NumPy + SciPy only, no compiled extensions needed</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import math\nfrom pychebyshev import ChebyshevApproximation\n\n# Define any smooth function\ndef my_func(x, _):\n    return math.sin(x[0]) * math.exp(-x[1])\n\n# Build interpolant\ncheb = ChebyshevApproximation(\n    my_func,\n    num_dimensions=2,\n    domain=[[-1, 1], [0, 2]],\n    n_nodes=[15, 15],\n)\ncheb.build()\n\n# Evaluate\nvalue = cheb.vectorized_eval([0.5, 1.0], [0, 0])\n\n# First derivative with respect to x[0]\ndfdx = cheb.vectorized_eval([0.5, 1.0], [1, 0])\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pychebyshev\n</code></pre>"},{"location":"#performance","title":"Performance","text":"Method Price Error Greek Error Build Time Query Time Chebyshev Barycentric 0.000% 1.980% ~0.35s ~0.065ms MoCaX Standard (C++) 0.000% 1.980% ~1.04s ~0.47ms FDM 0.803% 2.234% N/A ~500ms <p>Based on 5D Black-Scholes tests with 11 nodes per dimension.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#5d-black-scholes-performance","title":"5D Black-Scholes Performance","text":"<p>All benchmarks use 5D Black-Scholes: \\(V(S, K, T, \\sigma, r)\\) with 11 Chebyshev nodes per dimension (\\(11^5 = 161{,}051\\) grid points).</p>"},{"location":"benchmarks/#accuracy","title":"Accuracy","text":"Method Price Error Greek Error (max) Chebyshev Barycentric 0.000% 1.980% MoCaX Standard (C++) 0.000% 1.980% FDM (Crank-Nicolson) 0.803% 2.234% <p>Both Chebyshev methods achieve machine-precision price accuracy and identical Greek errors, as they compute the same unique interpolating polynomial.</p>"},{"location":"benchmarks/#timing","title":"Timing","text":"Method Build Time Price Query Price + 5 Greeks Chebyshev Barycentric 0.35s 0.065 ms 0.29 ms MoCaX Standard (C++) 1.04s 0.47 ms 2.85 ms Analytical (direct) N/A 0.01 ms 0.06 ms"},{"location":"benchmarks/#evaluation-method-comparison","title":"Evaluation Method Comparison","text":"<p>Within PyChebyshev, multiple evaluation paths exist:</p> Method Price Only Price + 5 Greeks Notes <code>eval()</code> ~45 ms ~270 ms Python loops, full validation <code>fast_eval()</code> ~10 ms ~95 ms Deprecated \u2014 JIT scalar loops <code>vectorized_eval()</code> 0.065 ms 0.39 ms Recommended \u2014 BLAS GEMV <code>vectorized_eval_multi()</code> \u2014 0.29 ms Shared weights across derivatives <p><code>vectorized_eval()</code> is the recommended default. Use <code>vectorized_eval_multi()</code> when computing multiple derivatives at the same point.</p> <p>Why BLAS beats JIT</p> <p><code>fast_eval()</code> uses Numba JIT to compile scalar barycentric interpolation loops. But <code>vectorized_eval()</code> restructures the algorithm into matrix-vector products (BLAS GEMV), replacing 16,105 Python loop iterations with 5 BLAS calls for a 5D problem. Optimized BLAS (OpenBLAS/MKL) running a single GEMV is fundamentally faster than JIT-compiled scalar loops \u2014 the data access pattern is more cache-friendly and leverages SIMD vectorization at the hardware level. <code>fast_eval()</code> is deprecated and will be removed in a future version.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#from-pypi","title":"From PyPI","text":"<pre><code>pip install pychebyshev\n</code></pre>"},{"location":"getting-started/#from-source-development","title":"From source (development)","text":"<pre><code>git clone https://github.com/0xC000005/PyChebyshev.git\ncd PyChebyshev\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/#1-define-your-function","title":"1. Define your function","text":"<p>PyChebyshev can approximate any smooth function. The function signature is <code>f(point, data) -&gt; float</code>, where <code>point</code> is a list of coordinates and <code>data</code> is optional additional data (pass <code>None</code> if unused).</p> <pre><code>import math\n\ndef my_func(x, _):\n    return math.sin(x[0]) + math.cos(x[1])\n</code></pre>"},{"location":"getting-started/#2-build-the-interpolant","title":"2. Build the interpolant","text":"<pre><code>from pychebyshev import ChebyshevApproximation\n\ncheb = ChebyshevApproximation(\n    function=my_func,\n    num_dimensions=2,\n    domain=[[-3, 3], [-3, 3]],  # bounds per dimension\n    n_nodes=[15, 15],            # Chebyshev nodes per dimension\n)\ncheb.build()\n</code></pre>"},{"location":"getting-started/#3-evaluate","title":"3. Evaluate","text":"<pre><code># Function value\nvalue = cheb.vectorized_eval([1.0, 2.0], [0, 0])\n\n# First derivative w.r.t. x[0]\ndfdx0 = cheb.vectorized_eval([1.0, 2.0], [1, 0])\n\n# Second derivative w.r.t. x[1]\nd2fdx1 = cheb.vectorized_eval([1.0, 2.0], [0, 2])\n</code></pre>"},{"location":"getting-started/#4-evaluate-price-all-greeks-at-once","title":"4. Evaluate price + all Greeks at once","text":"<p>For maximum efficiency when computing multiple derivatives at the same point:</p> <pre><code>results = cheb.vectorized_eval_multi(\n    [1.0, 2.0],\n    [\n        [0, 0],  # function value\n        [1, 0],  # df/dx0\n        [0, 1],  # df/dx1\n        [2, 0],  # d2f/dx0^2\n    ],\n)\n# results = [value, dfdx0, dfdx1, d2fdx0]\n</code></pre> <p>This shares barycentric weights across all derivative orders, saving ~25% compared to separate calls.</p>"},{"location":"getting-started/#5-save-for-later","title":"5. Save for later","text":"<p>Save the built interpolant to skip rebuilding next time:</p> <pre><code>cheb.save(\"my_interpolant.pkl\")\n</code></pre> <p>Load it back \u2014 no rebuild needed:</p> <pre><code>from pychebyshev import ChebyshevApproximation\n\ncheb = ChebyshevApproximation.load(\"my_interpolant.pkl\")\nvalue = cheb.vectorized_eval([1.0, 2.0], [0, 0])\n</code></pre> <p>See Saving &amp; Loading for details.</p>"},{"location":"getting-started/#choosing-node-counts","title":"Choosing Node Counts","text":"<ul> <li>10-15 nodes per dimension is typical for smooth analytic functions</li> <li>More nodes = higher accuracy but more build-time evaluations (\\(n_1 \\times n_2 \\times \\cdots\\))</li> <li>For 5D with 11 nodes: \\(11^5 = 161{,}051\\) function evaluations at build time</li> <li>Convergence is exponential for analytic functions \u2014 a few extra nodes can eliminate errors entirely</li> </ul>"},{"location":"api/reference/","title":"API Reference","text":""},{"location":"api/reference/#chebyshevapproximation","title":"ChebyshevApproximation","text":"<p>Multi-dimensional Chebyshev approximation using barycentric interpolation.</p> <p>Pre-computes barycentric weights for all dimensions at build time, enabling uniform O(N) evaluation complexity for every dimension. Supports analytical derivatives via spectral differentiation matrices.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>callable</code> <p>Function to approximate. Signature: <code>f(point, data) -&gt; float</code> where <code>point</code> is a list of floats and <code>data</code> is arbitrary additional data (can be None).</p> required <code>num_dimensions</code> <code>int</code> <p>Number of input dimensions.</p> required <code>domain</code> <code>list of (float, float)</code> <p>Bounds [(lo, hi), ...] for each dimension.</p> required <code>n_nodes</code> <code>list of int</code> <p>Number of Chebyshev nodes per dimension.</p> required <code>max_derivative_order</code> <code>int</code> <p>Maximum derivative order to support. Default is 2.</p> <code>2</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; def f(x, _):\n...     return math.sin(x[0]) + math.sin(x[1])\n&gt;&gt;&gt; cheb = ChebyshevApproximation(f, 2, [[-1, 1], [-1, 1]], [11, 11])\n&gt;&gt;&gt; cheb.build()\n&gt;&gt;&gt; cheb.vectorized_eval([0.5, 0.3], [0, 0])\n0.7764...\n</code></pre>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.build","title":"<code>build(verbose=True)</code>","text":"<p>Evaluate the function at all node combinations and pre-compute weights.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, print build progress. Default is True.</p> <code>True</code>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.eval","title":"<code>eval(point, derivative_order)</code>","text":"<p>Evaluate using dimensional decomposition with barycentric interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Query point, one coordinate per dimension.</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order per dimension (0 = function value, 1 = first derivative, 2 = second derivative).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Interpolated value or derivative at the query point.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>build()</code> has not been called.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.fast_eval","title":"<code>fast_eval(point, derivative_order)</code>","text":"<p>Fast evaluation using pre-allocated cache (skips validation).</p> <p>.. deprecated:: 0.3.0     Use :meth:<code>vectorized_eval</code> instead, which is ~150x faster via     BLAS GEMV and requires no optional dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Query point.</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Interpolated value or derivative.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.vectorized_eval","title":"<code>vectorized_eval(point, derivative_order)</code>","text":"<p>Fully vectorized evaluation using NumPy matrix operations.</p> <p>Replaces the Python loop with BLAS matrix-vector products. For 5-D with 11 nodes: 5 BLAS calls instead of 16,105 Python iterations.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Query point, one coordinate per dimension.</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Interpolated value or derivative.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>build()</code> has not been called.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.vectorized_eval_batch","title":"<code>vectorized_eval_batch(points, derivative_order)</code>","text":"<p>Evaluate at multiple points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Points of shape (N, num_dimensions).</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Results of shape (N,).</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.vectorized_eval_multi","title":"<code>vectorized_eval_multi(point, derivative_orders)</code>","text":"<p>Evaluate multiple derivative orders at the same point, sharing weights.</p> <p>Pre-computes normalized barycentric weights once per dimension and reuses them across all derivative orders. Computing price + 5 Greeks costs ~0.29 ms instead of 6 x 0.065 ms = 0.39 ms.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Query point.</p> required <code>derivative_orders</code> <code>list of list of int</code> <p>Each inner list specifies derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>list of float</code> <p>One result per derivative order.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>build()</code> has not been called.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.get_derivative_id","title":"<code>get_derivative_id(derivative_order)</code>","text":"<p>Return derivative order as-is (for API compatibility).</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Return picklable state, excluding the original function and eval cache.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Restore state and reconstruct the eval cache.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.save","title":"<code>save(path)</code>","text":"<p>Save the built interpolant to a file.</p> <p>The original function is not saved \u2014 only the numerical data needed for evaluation. The saved file can be loaded with :meth:<code>load</code> without access to the original function.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or path - like</code> <p>Destination file path.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the interpolant has not been built yet.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>Load a previously saved interpolant from a file.</p> <p>The loaded object can evaluate immediately; no rebuild is needed. The <code>function</code> attribute will be <code>None</code>. Assign a new function before calling <code>build()</code> again if a rebuild is desired.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or path - like</code> <p>Path to the saved file.</p> required <p>Returns:</p> Type Description <code>ChebyshevApproximation</code> <p>The restored interpolant.</p> <p>Warns:</p> Type Description <code>UserWarning</code> <p>If the file was saved with a different PyChebyshev version.</p> <code>.. warning::</code> <p>This method uses :mod:<code>pickle</code> internally. Pickle can execute arbitrary code during deserialization. Only load files you trust.</p>"},{"location":"api/reference/#chebyshevslider","title":"ChebyshevSlider","text":"<p>Chebyshev Sliding approximation for high-dimensional functions.</p> <p>Decomposes f(x_1, ..., x_n) into a sum of low-dimensional Chebyshev interpolants (slides) around a pivot point z:</p> <pre><code>f(x) \u2248 f(z) + \u03a3_i [s_i(x_group_i) - f(z)]\n</code></pre> <p>where each slide s_i is a ChebyshevApproximation built on a subset of dimensions with the remaining dimensions fixed at z.</p> <p>This trades accuracy for dramatically reduced build cost: instead of evaluating f at n_1 \u00d7 n_2 \u00d7 ... \u00d7 n_d grid points (exponential), the slider evaluates at n_1 \u00d7 n_2 + n_3 \u00d7 n_4 + ... (sum of products within each group).</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>callable</code> <p>Function to approximate. Signature: <code>f(point, data) -&gt; float</code> where <code>point</code> is a list of floats and <code>data</code> is arbitrary additional data (can be None).</p> required <code>num_dimensions</code> <code>int</code> <p>Total number of input dimensions.</p> required <code>domain</code> <code>list of (float, float)</code> <p>Bounds [lo, hi] for each dimension.</p> required <code>n_nodes</code> <code>list of int</code> <p>Number of Chebyshev nodes per dimension.</p> required <code>partition</code> <code>list of list of int</code> <p>Grouping of dimension indices into slides. Each dimension must appear in exactly one group. E.g. <code>[[0,1,2], [3,4]]</code> creates a 3D slide for dims 0,1,2 and a 2D slide for dims 3,4.</p> required <code>pivot_point</code> <code>list of float</code> <p>Reference point z around which slides are built.</p> required <code>max_derivative_order</code> <code>int</code> <p>Maximum derivative order to pre-compute (default 2).</p> <code>2</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; def f(x, _):\n...     return math.sin(x[0]) + math.sin(x[1]) + math.sin(x[2])\n&gt;&gt;&gt; slider = ChebyshevSlider(\n...     f, 3, [[-1,1], [-1,1], [-1,1]], [11,11,11],\n...     partition=[[0], [1], [2]],\n...     pivot_point=[0.0, 0.0, 0.0],\n... )\n&gt;&gt;&gt; slider.build(verbose=False)\n&gt;&gt;&gt; round(slider.eval([0.5, 0.3, 0.1], [0,0,0]), 4)\n0.8764\n</code></pre>"},{"location":"api/reference/#pychebyshev.ChebyshevSlider.total_build_evals","title":"<code>total_build_evals</code>  <code>property</code>","text":"<p>Total number of function evaluations used during build.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevSlider.build","title":"<code>build(verbose=True)</code>","text":"<p>Build all slides by evaluating the function at slide-specific grids.</p> <p>For each slide, dimensions outside the slide group are fixed at their pivot values.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, print build progress. Default is True.</p> <code>True</code>"},{"location":"api/reference/#pychebyshev.ChebyshevSlider.eval","title":"<code>eval(point, derivative_order)</code>","text":"<p>Evaluate the slider approximation at a point.</p> <p>Uses Equation 7.5 from Ruiz &amp; Zeron (2021):     f(x) \u2248 f(z) + \u03a3_i [s_i(x_i) - f(z)]</p> <p>For derivatives, only the slide containing that dimension contributes.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Evaluation point in the full n-dimensional space.</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order for each dimension (0 = function value).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Approximated function value or derivative.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevSlider.eval_multi","title":"<code>eval_multi(point, derivative_orders)</code>","text":"<p>Evaluate slider at multiple derivative orders for the same point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Evaluation point in the full n-dimensional space.</p> required <code>derivative_orders</code> <code>list of list of int</code> <p>Each inner list specifies derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>list of float</code> <p>Results for each derivative order.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevSlider.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Return picklable state, excluding the original function.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevSlider.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Restore state from a pickled dict.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevSlider.save","title":"<code>save(path)</code>","text":"<p>Save the built slider to a file.</p> <p>The original function is not saved \u2014 only the numerical data needed for evaluation. The saved file can be loaded with :meth:<code>load</code> without access to the original function.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or path - like</code> <p>Destination file path.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the slider has not been built yet.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevSlider.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>Load a previously saved slider from a file.</p> <p>The loaded object can evaluate immediately; no rebuild is needed. The <code>function</code> attribute will be <code>None</code>. Assign a new function before calling <code>build()</code> again if a rebuild is desired.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or path - like</code> <p>Path to the saved file.</p> required <p>Returns:</p> Type Description <code>ChebyshevSlider</code> <p>The restored slider.</p> <p>Warns:</p> Type Description <code>UserWarning</code> <p>If the file was saved with a different PyChebyshev version.</p> <code>.. warning::</code> <p>This method uses :mod:<code>pickle</code> internally. Pickle can execute arbitrary code during deserialization. Only load files you trust.</p>"},{"location":"api/reference/#module-functions","title":"Module Functions","text":"<p>Compute barycentric weights for given nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>ndarray</code> <p>Interpolation nodes of shape (n,).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Barycentric weights w_i = 1 / prod_{j!=i} (x_i - x_j).</p> <p>Compute spectral differentiation matrix for barycentric interpolation.</p> <p>Based on Berrut &amp; Trefethen (2004), Section 9.3.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>ndarray</code> <p>Interpolation nodes of shape (n,).</p> required <code>weights</code> <code>ndarray</code> <p>Barycentric weights of shape (n,).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Differentiation matrix D of shape (n, n) such that D @ f gives derivative values at nodes.</p> <p>Evaluate barycentric interpolation at a single point.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Evaluation point.</p> required <code>nodes</code> <code>ndarray</code> <p>Interpolation nodes.</p> required <code>values</code> <code>ndarray</code> <p>Function values at nodes.</p> required <code>weights</code> <code>ndarray</code> <p>Barycentric weights.</p> required <code>skip_check</code> <code>bool</code> <p>If True, skip node coincidence check (faster but may divide by zero).</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Interpolated value p(x).</p>"},{"location":"user-guide/concepts/","title":"Mathematical Concepts","text":""},{"location":"user-guide/concepts/#why-chebyshev-interpolation","title":"Why Chebyshev Interpolation?","text":"<p>Polynomial interpolation with equally-spaced points suffers from Runge's phenomenon \u2014 wild oscillations near interval endpoints that worsen as polynomial degree increases. Chebyshev nodes solve this by clustering near boundaries:</p> \\[x_i = \\cos\\left(\\frac{(2i-1)\\pi}{2n}\\right), \\quad i = 1, \\ldots, n\\] <p>The Lebesgue constant for Chebyshev nodes grows only logarithmically: \\(\\Lambda_n \\leq \\frac{2}{\\pi}\\log(n+1) + 1\\), versus exponential growth for equidistant points.</p>"},{"location":"user-guide/concepts/#spectral-convergence","title":"Spectral Convergence","text":"<p>For functions analytic in a Bernstein ellipse with parameter \\(\\rho &gt; 1\\), the interpolation error decays exponentially:</p> \\[|f(x) - p_N(x)| = O(\\rho^{-N})\\] <p>Each additional node multiplies accuracy by a constant factor \\(\\rho\\).</p>"},{"location":"user-guide/concepts/#barycentric-interpolation-formula","title":"Barycentric Interpolation Formula","text":"<p>The interpolating polynomial is expressed as:</p> \\[p(x) = \\frac{\\sum_{i=0}^{n} \\frac{w_i f_i}{x - x_i}}{\\sum_{i=0}^{n} \\frac{w_i}{x - x_i}}\\] <p>where the barycentric weights \\(w_i = 1 / \\prod_{j \\neq i}(x_i - x_j)\\) depend only on node positions, not on function values. This enables full pre-computation.</p>"},{"location":"user-guide/concepts/#multi-dimensional-extension","title":"Multi-Dimensional Extension","text":"<p>For a \\(d\\)-dimensional function, PyChebyshev uses dimensional decomposition:</p> <ol> <li>Start with the full tensor of function values at all node combinations</li> <li>Contract one dimension at a time using barycentric interpolation</li> <li>Each contraction reduces dimensionality by 1 (5D \u2192 4D \u2192 ... \u2192 scalar)</li> </ol> <p>This avoids the curse of dimensionality in the evaluation step \u2014 query cost scales linearly with the number of dimensions.</p>"},{"location":"user-guide/concepts/#analytical-derivatives","title":"Analytical Derivatives","text":"<p>Derivatives are computed using spectral differentiation matrices \\(D^{(k)}\\):</p> \\[D^{(1)}_{ij} = \\frac{w_j / w_i}{x_i - x_j} \\quad (i \\neq j), \\qquad D^{(1)}_{ii} = -\\sum_{k \\neq i} D^{(1)}_{ik}\\] <p>Given function values \\(\\mathbf{f}\\) at nodes, \\(D^{(1)} \\mathbf{f}\\) gives exact derivative values at those same nodes. These derivative values are then interpolated to the query point using the barycentric formula.</p>"},{"location":"user-guide/greeks/","title":"Computing Greeks","text":"<p>PyChebyshev computes option Greeks (and any partial derivatives) analytically using spectral differentiation matrices \u2014 no finite differences needed.</p>"},{"location":"user-guide/greeks/#derivative-specification","title":"Derivative Specification","text":"<p>Derivatives are specified as a list of integers, one per dimension. Each integer is the derivative order with respect to that dimension.</p> <p>For a 5D function \\(V(S, K, T, \\sigma, r)\\):</p> Greek <code>derivative_order</code> Mathematical Price <code>[0, 0, 0, 0, 0]</code> \\(V\\) Delta <code>[1, 0, 0, 0, 0]</code> \\(\\partial V / \\partial S\\) Gamma <code>[2, 0, 0, 0, 0]</code> \\(\\partial^2 V / \\partial S^2\\) Vega <code>[0, 0, 0, 1, 0]</code> \\(\\partial V / \\partial \\sigma\\) Rho <code>[0, 0, 0, 0, 1]</code> \\(\\partial V / \\partial r\\)"},{"location":"user-guide/greeks/#example-black-scholes-greeks","title":"Example: Black-Scholes Greeks","text":"<pre><code>from pychebyshev import ChebyshevApproximation\n\ndef black_scholes_call(x, _):\n    S, K, T, sigma, r = x\n    # ... your pricing function here\n    return price\n\ncheb = ChebyshevApproximation(\n    black_scholes_call, 5,\n    domain=[[80, 120], [90, 110], [0.25, 1.0], [0.15, 0.35], [0.01, 0.08]],\n    n_nodes=[11, 11, 11, 11, 11],\n)\ncheb.build()\n\npoint = [100, 100, 1.0, 0.25, 0.05]\n\n# All Greeks at once (most efficient)\nprice, delta, gamma, vega, rho = cheb.vectorized_eval_multi(point, [\n    [0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0],\n    [2, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 1],\n])\n</code></pre>"},{"location":"user-guide/greeks/#how-it-works","title":"How It Works","text":"<ol> <li>At build time: Pre-compute differentiation matrix \\(D\\) from node positions</li> <li>At query time: Apply \\(D\\) to the function value tensor before barycentric interpolation</li> <li>For second derivatives: apply \\(D\\) twice (\\(D^2 \\mathbf{f}\\))</li> <li>Interpolate the resulting derivative values to the query point</li> </ol> <p>This provides exact derivatives of the interpolating polynomial, preserving spectral accuracy.</p>"},{"location":"user-guide/greeks/#accuracy","title":"Accuracy","text":"<p>With 11 nodes per dimension on a 5D Black-Scholes test:</p> Greek Max Error Delta &lt; 0.01% Gamma &lt; 0.01% Vega ~1.98% Rho &lt; 0.01% <p>Vega has slightly higher error because volatility sensitivity involves a product of multiple terms, but remains well within practical tolerance.</p>"},{"location":"user-guide/serialization/","title":"Saving &amp; Loading Interpolants","text":""},{"location":"user-guide/serialization/#why-save","title":"Why Save?","text":"<p>Building a Chebyshev interpolant is the expensive step \u2014 it evaluates your function at every node in the tensor grid (e.g. \\(11^5 = 161{,}051\\) evaluations for a 5-D problem). Once built, evaluation takes microseconds.</p> <p>Saving a built interpolant lets you:</p> <ul> <li>Build once, evaluate forever \u2014 skip the build step in production</li> <li>Share models \u2014 distribute pre-built interpolants to team members or across machines</li> <li>Persist across sessions \u2014 save your work and reload it later</li> </ul>"},{"location":"user-guide/serialization/#saving-a-built-interpolant","title":"Saving a Built Interpolant","text":"<p>Both <code>ChebyshevApproximation</code> and <code>ChebyshevSlider</code> provide a <code>save()</code> method:</p> <pre><code>import math\nfrom pychebyshev import ChebyshevApproximation\n\ndef my_func(x, _):\n    return math.sin(x[0]) * math.exp(-x[1])\n\ncheb = ChebyshevApproximation(\n    my_func, 2, [[-1, 1], [0, 2]], [15, 15]\n)\ncheb.build()\n\n# Save to disk\ncheb.save(\"interpolant.pkl\")\n</code></pre> <p>For a <code>ChebyshevSlider</code>:</p> <pre><code>from pychebyshev import ChebyshevSlider\n\nslider = ChebyshevSlider(\n    my_func, 2, [[-1, 1], [0, 2]], [15, 15],\n    partition=[[0], [1]],\n    pivot_point=[0.0, 1.0],\n)\nslider.build()\n\nslider.save(\"slider.pkl\")\n</code></pre>"},{"location":"user-guide/serialization/#loading-an-interpolant","title":"Loading an Interpolant","text":"<p>Use the <code>load()</code> class method \u2014 no rebuild needed:</p> <pre><code>from pychebyshev import ChebyshevApproximation, ChebyshevSlider\n\n# Load and evaluate immediately\ncheb = ChebyshevApproximation.load(\"interpolant.pkl\")\nvalue = cheb.vectorized_eval([0.5, 1.0], [0, 0])\n\n# Works the same for sliders\nslider = ChebyshevSlider.load(\"slider.pkl\")\nvalue = slider.eval([0.5, 1.0], [0, 0])\n</code></pre> <p>The loaded <code>ChebyshevApproximation</code> supports all evaluation methods (<code>vectorized_eval</code>, <code>vectorized_eval_multi</code>, <code>vectorized_eval_batch</code>). The loaded <code>ChebyshevSlider</code> supports <code>eval</code> and <code>eval_multi</code>.</p>"},{"location":"user-guide/serialization/#inspecting-objects","title":"Inspecting Objects","text":"<p>Use <code>repr()</code> for a compact summary and <code>print()</code> for a detailed view:</p> <pre><code>cheb = ChebyshevApproximation.load(\"interpolant.pkl\")\n\nrepr(cheb)\n# ChebyshevApproximation(dims=2, nodes=[15, 15], built=True)\n\nprint(cheb)\n# ChebyshevApproximation (2D, built)\n#   Nodes:       [15, 15] (225 total)\n#   Domain:      [-1, 1] x [0, 2]\n#   Build:       0.002s, 225 evaluations\n#   Derivatives: up to order 2\n</code></pre> <p>For a slider:</p> <pre><code>print(slider)\n# ChebyshevSlider (5D, 2 slides, built)\n#   Partition: [[0, 1, 2], [3, 4]]\n#   Pivot:     [100.0, 1.0, 0.25, 0.05, 0.2]\n#   Nodes:     [11, 11, 11, 11, 11] (1,452 vs 161,051 full tensor)\n#   Domain:    [80.0, 120.0] x [0.5, 2.0] x [0.01, 0.5] x [0.01, 0.1] x [0.05, 0.5]\n#   Slides:\n#     [0] dims [0, 1, 2]: 1,331 evals, built in 0.189s\n#     [1] dims [3, 4]:     121 evals, built in 0.021s\n</code></pre> <p>This is useful for verifying that a loaded interpolant matches your expectations before using it.</p>"},{"location":"user-guide/serialization/#limitations","title":"Limitations","text":"<ul> <li> <p>The original function is not saved. Only the numerical data needed for   evaluation (nodes, weights, tensor values, differentiation matrices) is persisted.   After loading, <code>obj.function</code> is <code>None</code>.</p> </li> <li> <p>Calling <code>build()</code> on a loaded object requires reassigning a function first:</p> <pre><code>cheb = ChebyshevApproximation.load(\"interpolant.pkl\")\ncheb.function = my_func  # reassign before rebuilding\ncheb.build()\n</code></pre> </li> <li> <p>Version compatibility. If you load a file saved with a different version of   PyChebyshev, a warning is emitted. Evaluation results should be identical unless   internal data layout changed between versions.</p> </li> </ul> <p>Security</p> <p><code>load()</code> uses Python's <code>pickle</code> module internally. Pickle can execute arbitrary code during deserialization. Only load files you trust. Do not load interpolants from untrusted or unverified sources.</p>"},{"location":"user-guide/sliding/","title":"Sliding Technique","text":"<p>The Sliding Technique enables Chebyshev approximation of high-dimensional functions by decomposing them into a sum of low-dimensional interpolants. This sidesteps the curse of dimensionality at the cost of losing cross-group interactions.</p>"},{"location":"user-guide/sliding/#motivation","title":"Motivation","text":"<p>A full tensor Chebyshev interpolant on \\(n\\) dimensions with \\(m\\) nodes per dimension requires \\(m^n\\) function evaluations. For \\(n = 10\\) and \\(m = 11\\), that is over 25 billion evaluations \u2014 clearly infeasible.</p> <p>The sliding technique partitions the dimensions into small groups and builds a separate Chebyshev interpolant (a slide) for each group, with all other dimensions fixed at a pivot point. The total cost becomes the sum of the group grid sizes rather than their product.</p>"},{"location":"user-guide/sliding/#algorithm","title":"Algorithm","text":"<p>Given \\(f: \\mathbb{R}^n \\to \\mathbb{R}\\), a pivot point \\(\\mathbf{z} = (z_1, \\ldots, z_n)\\), and a partition of dimensions into \\(k\\) groups:</p> <ol> <li>Evaluate the pivot value \\(v = f(\\mathbf{z})\\).</li> <li>For each group \\(i\\), build a slide \\(s_i\\) \u2014 a Chebyshev interpolant on the group's dimensions, with all other dimensions fixed at their pivot values.</li> <li>Evaluate using the additive formula:</li> </ol> \\[ f(\\mathbf{x}) \\approx v + \\sum_{i=1}^{k} \\bigl[ s_i(\\mathbf{x}_{G_i}) - v \\bigr] \\] <p>where \\(\\mathbf{x}_{G_i}\\) denotes the components of \\(\\mathbf{x}\\) belonging to group \\(i\\).</p>"},{"location":"user-guide/sliding/#when-to-use-sliding","title":"When to Use Sliding","text":"<p>Sliding works well when:</p> <ul> <li>The function is additively separable or nearly so (e.g., \\(\\sin(x_1) + \\sin(x_2) + \\sin(x_3)\\)).</li> <li>Cross-group interactions are weak relative to within-group effects.</li> <li>The number of dimensions is too large for full tensor interpolation (say, \\(n &gt; 6\\)).</li> </ul> <p>Sliding does not work well when:</p> <ul> <li>Variables in different groups are strongly coupled (e.g., Black-Scholes where \\(S\\), \\(T\\), and \\(\\sigma\\) interact multiplicatively).</li> <li>High accuracy is required far from the pivot point.</li> </ul> <p>Choosing the partition</p> <p>Group variables that have strong non-linear interactions together. For example, if \\(f = x_1^3 x_2^2 + x_3\\), group \\((x_1, x_2)\\) in one slide and \\(x_3\\) in another.</p>"},{"location":"user-guide/sliding/#usage","title":"Usage","text":"<pre><code>import math\nfrom pychebyshev import ChebyshevSlider\n\n# Additively separable function\ndef f(x, _):\n    return math.sin(x[0]) + math.sin(x[1]) + math.sin(x[2])\n\nslider = ChebyshevSlider(\n    function=f,\n    num_dimensions=3,\n    domain=[[-1, 1], [-1, 1], [-1, 1]],\n    n_nodes=[11, 11, 11],\n    partition=[[0], [1], [2]],       # each dim is its own slide\n    pivot_point=[0.0, 0.0, 0.0],\n)\nslider.build()\n\n# Evaluate function value\nval = slider.eval([0.5, 0.3, -0.2], [0, 0, 0])\n\n# Evaluate derivative w.r.t. x0\ndfdx0 = slider.eval([0.5, 0.3, -0.2], [1, 0, 0])\n</code></pre>"},{"location":"user-guide/sliding/#multi-dimensional-slides","title":"Multi-dimensional slides","text":"<p>For functions with within-group coupling, use larger groups:</p> <pre><code>def g(x, _):\n    return x[0]**3 * x[1]**2 + math.sin(x[2]) + math.sin(x[3])\n\nslider = ChebyshevSlider(\n    function=g,\n    num_dimensions=4,\n    domain=[[-2, 2], [-2, 2], [-1, 1], [-1, 1]],\n    n_nodes=[12, 12, 8, 8],\n    partition=[[0, 1], [2], [3]],    # 2D + 1D + 1D\n    pivot_point=[0.0, 0.0, 0.0, 0.0],\n)\nslider.build()\n</code></pre>"},{"location":"user-guide/sliding/#build-cost-comparison","title":"Build cost comparison","text":"<pre><code># Full tensor: 12 * 12 * 8 * 8 = 9,216 evaluations\n# Sliding:     12*12 + 8 + 8   = 160 evaluations  (57x fewer)\nprint(f\"Slider build evaluations: {slider.total_build_evals}\")\n</code></pre>"},{"location":"user-guide/sliding/#derivatives","title":"Derivatives","text":"<p>The slider supports analytical derivatives through its slides. Only the slide containing the differentiated dimension contributes:</p> \\[ \\frac{\\partial}{\\partial x_j} f(\\mathbf{x}) \\approx \\frac{\\partial}{\\partial x_j} s_i(\\mathbf{x}_{G_i}) \\] <p>where \\(j \\in G_i\\). The pivot value \\(v\\) is constant and drops out.</p> <pre><code># Multiple derivatives at once\nresults = slider.eval_multi(\n    [0.5, 0.3, -0.2],\n    [\n        [0, 0, 0],  # function value\n        [1, 0, 0],  # d/dx0\n        [0, 1, 0],  # d/dx1\n        [0, 0, 1],  # d/dx2\n    ],\n)\n</code></pre>"},{"location":"user-guide/sliding/#limitations","title":"Limitations","text":""},{"location":"user-guide/sliding/#cross-group-derivatives-are-zero","title":"Cross-group derivatives are zero","text":"<p>Because slides are independent functions of disjoint variable groups, mixed partial derivatives across groups are exactly zero. For example, with partition <code>[[0, 1], [2]]</code>:</p> <ul> <li>\\(\\frac{\\partial^2 f}{\\partial x_0 \\partial x_1}\\) \u2014 computed within the <code>[0, 1]</code> slide (correct)</li> <li>\\(\\frac{\\partial^2 f}{\\partial x_0 \\partial x_2}\\) \u2014 returns 0 (x\u2080 and x\u2082 are in different slides)</li> </ul> <p>This is mathematically correct for the sliding approximation, but may differ from the true function's cross-derivatives. If cross-group sensitivities matter, group those variables together or use full tensor interpolation.</p>"},{"location":"user-guide/sliding/#accuracy-degrades-far-from-pivot","title":"Accuracy degrades far from pivot","text":"<p>The sliding approximation is most accurate near the pivot point. As the evaluation point moves away from the pivot in multiple dimensions simultaneously, cross-coupling errors accumulate. For strongly coupled functions like Black-Scholes, this can produce 20-50% errors at domain boundaries.</p>"},{"location":"user-guide/sliding/#api-reference","title":"API Reference","text":"<p>Chebyshev Sliding approximation for high-dimensional functions.</p> <p>Decomposes f(x_1, ..., x_n) into a sum of low-dimensional Chebyshev interpolants (slides) around a pivot point z:</p> <pre><code>f(x) \u2248 f(z) + \u03a3_i [s_i(x_group_i) - f(z)]\n</code></pre> <p>where each slide s_i is a ChebyshevApproximation built on a subset of dimensions with the remaining dimensions fixed at z.</p> <p>This trades accuracy for dramatically reduced build cost: instead of evaluating f at n_1 \u00d7 n_2 \u00d7 ... \u00d7 n_d grid points (exponential), the slider evaluates at n_1 \u00d7 n_2 + n_3 \u00d7 n_4 + ... (sum of products within each group).</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>callable</code> <p>Function to approximate. Signature: <code>f(point, data) -&gt; float</code> where <code>point</code> is a list of floats and <code>data</code> is arbitrary additional data (can be None).</p> required <code>num_dimensions</code> <code>int</code> <p>Total number of input dimensions.</p> required <code>domain</code> <code>list of (float, float)</code> <p>Bounds [lo, hi] for each dimension.</p> required <code>n_nodes</code> <code>list of int</code> <p>Number of Chebyshev nodes per dimension.</p> required <code>partition</code> <code>list of list of int</code> <p>Grouping of dimension indices into slides. Each dimension must appear in exactly one group. E.g. <code>[[0,1,2], [3,4]]</code> creates a 3D slide for dims 0,1,2 and a 2D slide for dims 3,4.</p> required <code>pivot_point</code> <code>list of float</code> <p>Reference point z around which slides are built.</p> required <code>max_derivative_order</code> <code>int</code> <p>Maximum derivative order to pre-compute (default 2).</p> <code>2</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; def f(x, _):\n...     return math.sin(x[0]) + math.sin(x[1]) + math.sin(x[2])\n&gt;&gt;&gt; slider = ChebyshevSlider(\n...     f, 3, [[-1,1], [-1,1], [-1,1]], [11,11,11],\n...     partition=[[0], [1], [2]],\n...     pivot_point=[0.0, 0.0, 0.0],\n... )\n&gt;&gt;&gt; slider.build(verbose=False)\n&gt;&gt;&gt; round(slider.eval([0.5, 0.3, 0.1], [0,0,0]), 4)\n0.8764\n</code></pre>"},{"location":"user-guide/sliding/#pychebyshev.slider.ChebyshevSlider.total_build_evals","title":"<code>total_build_evals</code>  <code>property</code>","text":"<p>Total number of function evaluations used during build.</p>"},{"location":"user-guide/sliding/#pychebyshev.slider.ChebyshevSlider.build","title":"<code>build(verbose=True)</code>","text":"<p>Build all slides by evaluating the function at slide-specific grids.</p> <p>For each slide, dimensions outside the slide group are fixed at their pivot values.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, print build progress. Default is True.</p> <code>True</code>"},{"location":"user-guide/sliding/#pychebyshev.slider.ChebyshevSlider.eval","title":"<code>eval(point, derivative_order)</code>","text":"<p>Evaluate the slider approximation at a point.</p> <p>Uses Equation 7.5 from Ruiz &amp; Zeron (2021):     f(x) \u2248 f(z) + \u03a3_i [s_i(x_i) - f(z)]</p> <p>For derivatives, only the slide containing that dimension contributes.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Evaluation point in the full n-dimensional space.</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order for each dimension (0 = function value).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Approximated function value or derivative.</p>"},{"location":"user-guide/sliding/#pychebyshev.slider.ChebyshevSlider.eval_multi","title":"<code>eval_multi(point, derivative_orders)</code>","text":"<p>Evaluate slider at multiple derivative orders for the same point.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Evaluation point in the full n-dimensional space.</p> required <code>derivative_orders</code> <code>list of list of int</code> <p>Each inner list specifies derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>list of float</code> <p>Results for each derivative order.</p>"},{"location":"user-guide/sliding/#pychebyshev.slider.ChebyshevSlider.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Return picklable state, excluding the original function.</p>"},{"location":"user-guide/sliding/#pychebyshev.slider.ChebyshevSlider.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Restore state from a pickled dict.</p>"},{"location":"user-guide/sliding/#pychebyshev.slider.ChebyshevSlider.save","title":"<code>save(path)</code>","text":"<p>Save the built slider to a file.</p> <p>The original function is not saved \u2014 only the numerical data needed for evaluation. The saved file can be loaded with :meth:<code>load</code> without access to the original function.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or path - like</code> <p>Destination file path.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the slider has not been built yet.</p>"},{"location":"user-guide/sliding/#pychebyshev.slider.ChebyshevSlider.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>Load a previously saved slider from a file.</p> <p>The loaded object can evaluate immediately; no rebuild is needed. The <code>function</code> attribute will be <code>None</code>. Assign a new function before calling <code>build()</code> again if a rebuild is desired.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or path - like</code> <p>Path to the saved file.</p> required <p>Returns:</p> Type Description <code>ChebyshevSlider</code> <p>The restored slider.</p> <p>Warns:</p> Type Description <code>UserWarning</code> <p>If the file was saved with a different PyChebyshev version.</p> <code>.. warning::</code> <p>This method uses :mod:<code>pickle</code> internally. Pickle can execute arbitrary code during deserialization. Only load files you trust.</p>"},{"location":"user-guide/usage/","title":"Usage Patterns","text":""},{"location":"user-guide/usage/#basic-workflow","title":"Basic Workflow","text":"<p>Every PyChebyshev workflow follows three steps:</p> <ol> <li>Define a callable function</li> <li>Build the interpolant (evaluates at Chebyshev nodes, pre-computes weights)</li> <li>Query at arbitrary points</li> </ol> <pre><code>from pychebyshev import ChebyshevApproximation\n\ncheb = ChebyshevApproximation(func, num_dimensions, domain, n_nodes)\ncheb.build()\nresult = cheb.vectorized_eval(point, derivative_order)\n</code></pre>"},{"location":"user-guide/usage/#evaluation-methods","title":"Evaluation Methods","text":"<p>PyChebyshev provides several evaluation methods with different speed/safety tradeoffs:</p> Method Speed Safety Use When <code>eval()</code> Slowest Full validation Testing and debugging <code>vectorized_eval()</code> Fastest Full validation Default choice <code>vectorized_eval_multi()</code> Fastest (multi) Full validation Price + Greeks at same point <p>Why no JIT?</p> <p>Earlier versions offered a Numba JIT <code>fast_eval()</code> path, but <code>vectorized_eval()</code> is ~150x faster because it routes N-D tensor contractions through BLAS GEMV \u2014 a single optimized matrix-vector multiply per dimension. JIT compilation cannot beat BLAS for this workload. <code>fast_eval()</code> is deprecated and will be removed in a future version.</p>"},{"location":"user-guide/usage/#vectorized_eval-recommended","title":"<code>vectorized_eval()</code> \u2014 Recommended","text":"<p>Uses BLAS matrix-vector products. For 5D with 11 nodes, replaces 16,105 Python loop iterations with 5 BLAS calls:</p> <pre><code>price = cheb.vectorized_eval([100, 100, 1.0, 0.25, 0.05], [0, 0, 0, 0, 0])\n</code></pre>"},{"location":"user-guide/usage/#vectorized_eval_multi-best-for-multiple-derivatives","title":"<code>vectorized_eval_multi()</code> \u2014 Best for multiple derivatives","text":"<p>Pre-computes normalized barycentric weights once, reuses across all derivative orders:</p> <pre><code>results = cheb.vectorized_eval_multi(\n    [100, 100, 1.0, 0.25, 0.05],\n    [\n        [0, 0, 0, 0, 0],  # price\n        [1, 0, 0, 0, 0],  # delta (dV/dS)\n        [2, 0, 0, 0, 0],  # gamma (d\u00b2V/dS\u00b2)\n        [0, 0, 0, 1, 0],  # vega  (dV/d\u03c3)\n        [0, 0, 0, 0, 1],  # rho   (dV/dr)\n    ],\n)\nprice, delta, gamma, vega, rho = results\n</code></pre>"},{"location":"user-guide/usage/#batch-evaluation","title":"Batch Evaluation","text":"<p>For evaluating at many points:</p> <pre><code>import numpy as np\n\npoints = np.array([\n    [100, 100, 1.0, 0.25, 0.05],\n    [110, 100, 1.0, 0.25, 0.05],\n    [90, 100, 1.0, 0.25, 0.05],\n])\nprices = cheb.vectorized_eval_batch(points, [0, 0, 0, 0, 0])\n</code></pre>"},{"location":"user-guide/usage/#function-signature","title":"Function Signature","text":"<p>The function passed to <code>ChebyshevApproximation</code> must accept:</p> <ul> <li><code>point</code> \u2014 a list of floats (one per dimension)</li> <li><code>data</code> \u2014 arbitrary additional data (use <code>None</code> if not needed)</li> </ul> <pre><code>def my_func(point, data):\n    x, y, z = point\n    return x**2 + y * z\n</code></pre>"}]}