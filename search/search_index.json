{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyChebyshev","text":"<p>Fast multi-dimensional Chebyshev tensor interpolation with analytical derivatives.</p> <p>PyChebyshev builds a Chebyshev interpolant of any smooth function in up to N dimensions, then evaluates it and its derivatives in microseconds using vectorized NumPy operations.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Spectral accuracy \u2014 exponential error decay as node count increases</li> <li>Analytical derivatives \u2014 via spectral differentiation matrices (no finite differences)</li> <li>Fast evaluation \u2014 ~0.065 ms per query (price), ~0.29 ms for price + 5 Greeks</li> <li>Minimal storage \u2014 55 floats (440 bytes) for a 5D interpolant with 11 nodes per dimension</li> <li>Pure Python \u2014 NumPy + SciPy only; optional Numba JIT for additional speed</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import math\nfrom pychebyshev import ChebyshevApproximation\n\n# Define any smooth function\ndef my_func(x, _):\n    return math.sin(x[0]) * math.exp(-x[1])\n\n# Build interpolant\ncheb = ChebyshevApproximation(\n    my_func,\n    num_dimensions=2,\n    domain=[[-1, 1], [0, 2]],\n    n_nodes=[15, 15],\n)\ncheb.build()\n\n# Evaluate\nvalue = cheb.vectorized_eval([0.5, 1.0], [0, 0])\n\n# First derivative with respect to x[0]\ndfdx = cheb.vectorized_eval([0.5, 1.0], [1, 0])\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pychebyshev\n</code></pre> <p>For Numba JIT acceleration:</p> <pre><code>pip install pychebyshev[jit]\n</code></pre>"},{"location":"#performance","title":"Performance","text":"Method Price Error Greek Error Build Time Query Time Chebyshev Barycentric 0.000% 1.980% ~0.35s ~0.065ms MoCaX Standard (C++) 0.000% 1.980% ~1.04s ~0.47ms FDM 0.803% 2.234% N/A ~500ms <p>Based on 5D Black-Scholes tests with 11 nodes per dimension.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#5d-black-scholes-performance","title":"5D Black-Scholes Performance","text":"<p>All benchmarks use 5D Black-Scholes: \\(V(S, K, T, \\sigma, r)\\) with 11 Chebyshev nodes per dimension (\\(11^5 = 161{,}051\\) grid points).</p>"},{"location":"benchmarks/#accuracy","title":"Accuracy","text":"Method Price Error Greek Error (max) Chebyshev Barycentric 0.000% 1.980% MoCaX Standard (C++) 0.000% 1.980% FDM (Crank-Nicolson) 0.803% 2.234% <p>Both Chebyshev methods achieve machine-precision price accuracy and identical Greek errors, as they compute the same unique interpolating polynomial.</p>"},{"location":"benchmarks/#timing","title":"Timing","text":"Method Build Time Price Query Price + 5 Greeks Chebyshev Barycentric 0.35s 0.065 ms 0.29 ms MoCaX Standard (C++) 1.04s 0.47 ms 2.85 ms Analytical (direct) N/A 0.01 ms 0.06 ms"},{"location":"benchmarks/#evaluation-method-comparison","title":"Evaluation Method Comparison","text":"<p>Within PyChebyshev, multiple evaluation paths exist:</p> Method Price Only Price + 5 Greeks <code>eval()</code> ~45 ms ~270 ms <code>fast_eval()</code> ~10 ms ~95 ms <code>vectorized_eval()</code> 0.065 ms 0.39 ms <code>vectorized_eval_multi()</code> \u2014 0.29 ms <p><code>vectorized_eval()</code> is the recommended default. Use <code>vectorized_eval_multi()</code> when computing multiple derivatives at the same point.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#from-pypi","title":"From PyPI","text":"<pre><code>pip install pychebyshev\n</code></pre>"},{"location":"getting-started/#with-numba-jit-acceleration","title":"With Numba JIT acceleration","text":"<pre><code>pip install pychebyshev[jit]\n</code></pre>"},{"location":"getting-started/#from-source-development","title":"From source (development)","text":"<pre><code>git clone https://github.com/maxjingwezhang/PyChebyshev.git\ncd PyChebyshev\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/#1-define-your-function","title":"1. Define your function","text":"<p>PyChebyshev can approximate any smooth function. The function signature is <code>f(point, data) -&gt; float</code>, where <code>point</code> is a list of coordinates and <code>data</code> is optional additional data (pass <code>None</code> if unused).</p> <pre><code>import math\n\ndef my_func(x, _):\n    return math.sin(x[0]) + math.cos(x[1])\n</code></pre>"},{"location":"getting-started/#2-build-the-interpolant","title":"2. Build the interpolant","text":"<pre><code>from pychebyshev import ChebyshevApproximation\n\ncheb = ChebyshevApproximation(\n    function=my_func,\n    num_dimensions=2,\n    domain=[[-3, 3], [-3, 3]],  # bounds per dimension\n    n_nodes=[15, 15],            # Chebyshev nodes per dimension\n)\ncheb.build()\n</code></pre>"},{"location":"getting-started/#3-evaluate","title":"3. Evaluate","text":"<pre><code># Function value\nvalue = cheb.vectorized_eval([1.0, 2.0], [0, 0])\n\n# First derivative w.r.t. x[0]\ndfdx0 = cheb.vectorized_eval([1.0, 2.0], [1, 0])\n\n# Second derivative w.r.t. x[1]\nd2fdx1 = cheb.vectorized_eval([1.0, 2.0], [0, 2])\n</code></pre>"},{"location":"getting-started/#4-evaluate-price-all-greeks-at-once","title":"4. Evaluate price + all Greeks at once","text":"<p>For maximum efficiency when computing multiple derivatives at the same point:</p> <pre><code>results = cheb.vectorized_eval_multi(\n    [1.0, 2.0],\n    [\n        [0, 0],  # function value\n        [1, 0],  # df/dx0\n        [0, 1],  # df/dx1\n        [2, 0],  # d2f/dx0^2\n    ],\n)\n# results = [value, dfdx0, dfdx1, d2fdx0]\n</code></pre> <p>This shares barycentric weights across all derivative orders, saving ~25% compared to separate calls.</p>"},{"location":"getting-started/#choosing-node-counts","title":"Choosing Node Counts","text":"<ul> <li>10-15 nodes per dimension is typical for smooth analytic functions</li> <li>More nodes = higher accuracy but more build-time evaluations (\\(n_1 \\times n_2 \\times \\cdots\\))</li> <li>For 5D with 11 nodes: \\(11^5 = 161{,}051\\) function evaluations at build time</li> <li>Convergence is exponential for analytic functions \u2014 a few extra nodes can eliminate errors entirely</li> </ul>"},{"location":"api/reference/","title":"API Reference","text":""},{"location":"api/reference/#chebyshevapproximation","title":"ChebyshevApproximation","text":"<p>Multi-dimensional Chebyshev approximation using barycentric interpolation.</p> <p>Pre-computes barycentric weights for all dimensions at build time, enabling uniform O(N) evaluation complexity for every dimension. Supports analytical derivatives via spectral differentiation matrices.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>callable</code> <p>Function to approximate. Signature: <code>f(point, data) -&gt; float</code> where <code>point</code> is a list of floats and <code>data</code> is arbitrary additional data (can be None).</p> required <code>num_dimensions</code> <code>int</code> <p>Number of input dimensions.</p> required <code>domain</code> <code>list of (float, float)</code> <p>Bounds [(lo, hi), ...] for each dimension.</p> required <code>n_nodes</code> <code>list of int</code> <p>Number of Chebyshev nodes per dimension.</p> required <code>max_derivative_order</code> <code>int</code> <p>Maximum derivative order to support. Default is 2.</p> <code>2</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; def f(x, _):\n...     return math.sin(x[0]) + math.sin(x[1])\n&gt;&gt;&gt; cheb = ChebyshevApproximation(f, 2, [[-1, 1], [-1, 1]], [11, 11])\n&gt;&gt;&gt; cheb.build()\n&gt;&gt;&gt; cheb.vectorized_eval([0.5, 0.3], [0, 0])\n0.7764...\n</code></pre>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.build","title":"<code>build(verbose=True)</code>","text":"<p>Evaluate the function at all node combinations and pre-compute weights.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, print build progress. Default is True.</p> <code>True</code>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.eval","title":"<code>eval(point, derivative_order)</code>","text":"<p>Evaluate using dimensional decomposition with barycentric interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Query point, one coordinate per dimension.</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order per dimension (0 = function value, 1 = first derivative, 2 = second derivative).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Interpolated value or derivative at the query point.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>build()</code> has not been called.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.fast_eval","title":"<code>fast_eval(point, derivative_order)</code>","text":"<p>Fast evaluation using pre-allocated cache (skips validation).</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Query point.</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Interpolated value or derivative.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.vectorized_eval","title":"<code>vectorized_eval(point, derivative_order)</code>","text":"<p>Fully vectorized evaluation using NumPy matrix operations.</p> <p>Replaces the Python loop with BLAS matrix-vector products. For 5-D with 11 nodes: 5 BLAS calls instead of 16,105 Python iterations.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Query point, one coordinate per dimension.</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Interpolated value or derivative.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>build()</code> has not been called.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.vectorized_eval_batch","title":"<code>vectorized_eval_batch(points, derivative_order)</code>","text":"<p>Evaluate at multiple points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Points of shape (N, num_dimensions).</p> required <code>derivative_order</code> <code>list of int</code> <p>Derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Results of shape (N,).</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.vectorized_eval_multi","title":"<code>vectorized_eval_multi(point, derivative_orders)</code>","text":"<p>Evaluate multiple derivative orders at the same point, sharing weights.</p> <p>Pre-computes normalized barycentric weights once per dimension and reuses them across all derivative orders. Computing price + 5 Greeks costs ~0.29 ms instead of 6 x 0.065 ms = 0.39 ms.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>list of float</code> <p>Query point.</p> required <code>derivative_orders</code> <code>list of list of int</code> <p>Each inner list specifies derivative order per dimension.</p> required <p>Returns:</p> Type Description <code>list of float</code> <p>One result per derivative order.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>build()</code> has not been called.</p>"},{"location":"api/reference/#pychebyshev.ChebyshevApproximation.get_derivative_id","title":"<code>get_derivative_id(derivative_order)</code>","text":"<p>Return derivative order as-is (for API compatibility).</p>"},{"location":"api/reference/#module-functions","title":"Module Functions","text":"<p>Compute barycentric weights for given nodes.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>ndarray</code> <p>Interpolation nodes of shape (n,).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Barycentric weights w_i = 1 / prod_{j!=i} (x_i - x_j).</p> <p>Compute spectral differentiation matrix for barycentric interpolation.</p> <p>Based on Berrut &amp; Trefethen (2004), Section 9.3.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>ndarray</code> <p>Interpolation nodes of shape (n,).</p> required <code>weights</code> <code>ndarray</code> <p>Barycentric weights of shape (n,).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Differentiation matrix D of shape (n, n) such that D @ f gives derivative values at nodes.</p> <p>Evaluate barycentric interpolation at a single point.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Evaluation point.</p> required <code>nodes</code> <code>ndarray</code> <p>Interpolation nodes.</p> required <code>values</code> <code>ndarray</code> <p>Function values at nodes.</p> required <code>weights</code> <code>ndarray</code> <p>Barycentric weights.</p> required <code>skip_check</code> <code>bool</code> <p>If True, skip node coincidence check (faster but may divide by zero).</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Interpolated value p(x).</p>"},{"location":"user-guide/concepts/","title":"Mathematical Concepts","text":""},{"location":"user-guide/concepts/#why-chebyshev-interpolation","title":"Why Chebyshev Interpolation?","text":"<p>Polynomial interpolation with equally-spaced points suffers from Runge's phenomenon \u2014 wild oscillations near interval endpoints that worsen as polynomial degree increases. Chebyshev nodes solve this by clustering near boundaries:</p> \\[x_i = \\cos\\left(\\frac{(2i-1)\\pi}{2n}\\right), \\quad i = 1, \\ldots, n\\] <p>The Lebesgue constant for Chebyshev nodes grows only logarithmically: \\(\\Lambda_n \\leq \\frac{2}{\\pi}\\log(n+1) + 1\\), versus exponential growth for equidistant points.</p>"},{"location":"user-guide/concepts/#spectral-convergence","title":"Spectral Convergence","text":"<p>For functions analytic in a Bernstein ellipse with parameter \\(\\rho &gt; 1\\), the interpolation error decays exponentially:</p> \\[|f(x) - p_N(x)| = O(\\rho^{-N})\\] <p>Each additional node multiplies accuracy by a constant factor \\(\\rho\\).</p>"},{"location":"user-guide/concepts/#barycentric-interpolation-formula","title":"Barycentric Interpolation Formula","text":"<p>The interpolating polynomial is expressed as:</p> \\[p(x) = \\frac{\\sum_{i=0}^{n} \\frac{w_i f_i}{x - x_i}}{\\sum_{i=0}^{n} \\frac{w_i}{x - x_i}}\\] <p>where the barycentric weights \\(w_i = 1 / \\prod_{j \\neq i}(x_i - x_j)\\) depend only on node positions, not on function values. This enables full pre-computation.</p>"},{"location":"user-guide/concepts/#multi-dimensional-extension","title":"Multi-Dimensional Extension","text":"<p>For a \\(d\\)-dimensional function, PyChebyshev uses dimensional decomposition:</p> <ol> <li>Start with the full tensor of function values at all node combinations</li> <li>Contract one dimension at a time using barycentric interpolation</li> <li>Each contraction reduces dimensionality by 1 (5D \u2192 4D \u2192 ... \u2192 scalar)</li> </ol> <p>This avoids the curse of dimensionality in the evaluation step \u2014 query cost scales linearly with the number of dimensions.</p>"},{"location":"user-guide/concepts/#analytical-derivatives","title":"Analytical Derivatives","text":"<p>Derivatives are computed using spectral differentiation matrices \\(D^{(k)}\\):</p> \\[D^{(1)}_{ij} = \\frac{w_j / w_i}{x_i - x_j} \\quad (i \\neq j), \\qquad D^{(1)}_{ii} = -\\sum_{k \\neq i} D^{(1)}_{ik}\\] <p>Given function values \\(\\mathbf{f}\\) at nodes, \\(D^{(1)} \\mathbf{f}\\) gives exact derivative values at those same nodes. These derivative values are then interpolated to the query point using the barycentric formula.</p>"},{"location":"user-guide/greeks/","title":"Computing Greeks","text":"<p>PyChebyshev computes option Greeks (and any partial derivatives) analytically using spectral differentiation matrices \u2014 no finite differences needed.</p>"},{"location":"user-guide/greeks/#derivative-specification","title":"Derivative Specification","text":"<p>Derivatives are specified as a list of integers, one per dimension. Each integer is the derivative order with respect to that dimension.</p> <p>For a 5D function \\(V(S, K, T, \\sigma, r)\\):</p> Greek <code>derivative_order</code> Mathematical Price <code>[0, 0, 0, 0, 0]</code> \\(V\\) Delta <code>[1, 0, 0, 0, 0]</code> \\(\\partial V / \\partial S\\) Gamma <code>[2, 0, 0, 0, 0]</code> \\(\\partial^2 V / \\partial S^2\\) Vega <code>[0, 0, 0, 1, 0]</code> \\(\\partial V / \\partial \\sigma\\) Rho <code>[0, 0, 0, 0, 1]</code> \\(\\partial V / \\partial r\\)"},{"location":"user-guide/greeks/#example-black-scholes-greeks","title":"Example: Black-Scholes Greeks","text":"<pre><code>from pychebyshev import ChebyshevApproximation\n\ndef black_scholes_call(x, _):\n    S, K, T, sigma, r = x\n    # ... your pricing function here\n    return price\n\ncheb = ChebyshevApproximation(\n    black_scholes_call, 5,\n    domain=[[80, 120], [90, 110], [0.25, 1.0], [0.15, 0.35], [0.01, 0.08]],\n    n_nodes=[11, 11, 11, 11, 11],\n)\ncheb.build()\n\npoint = [100, 100, 1.0, 0.25, 0.05]\n\n# All Greeks at once (most efficient)\nprice, delta, gamma, vega, rho = cheb.vectorized_eval_multi(point, [\n    [0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0],\n    [2, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 1],\n])\n</code></pre>"},{"location":"user-guide/greeks/#how-it-works","title":"How It Works","text":"<ol> <li>At build time: Pre-compute differentiation matrix \\(D\\) from node positions</li> <li>At query time: Apply \\(D\\) to the function value tensor before barycentric interpolation</li> <li>For second derivatives: apply \\(D\\) twice (\\(D^2 \\mathbf{f}\\))</li> <li>Interpolate the resulting derivative values to the query point</li> </ol> <p>This provides exact derivatives of the interpolating polynomial, preserving spectral accuracy.</p>"},{"location":"user-guide/greeks/#accuracy","title":"Accuracy","text":"<p>With 11 nodes per dimension on a 5D Black-Scholes test:</p> Greek Max Error Delta &lt; 0.01% Gamma &lt; 0.01% Vega ~1.98% Rho &lt; 0.01% <p>Vega has slightly higher error because volatility sensitivity involves a product of multiple terms, but remains well within practical tolerance.</p>"},{"location":"user-guide/usage/","title":"Usage Patterns","text":""},{"location":"user-guide/usage/#basic-workflow","title":"Basic Workflow","text":"<p>Every PyChebyshev workflow follows three steps:</p> <ol> <li>Define a callable function</li> <li>Build the interpolant (evaluates at Chebyshev nodes, pre-computes weights)</li> <li>Query at arbitrary points</li> </ol> <pre><code>from pychebyshev import ChebyshevApproximation\n\ncheb = ChebyshevApproximation(func, num_dimensions, domain, n_nodes)\ncheb.build()\nresult = cheb.vectorized_eval(point, derivative_order)\n</code></pre>"},{"location":"user-guide/usage/#evaluation-methods","title":"Evaluation Methods","text":"<p>PyChebyshev provides several evaluation methods with different speed/safety tradeoffs:</p> Method Speed Safety Use When <code>eval()</code> Slowest Full validation Testing and debugging <code>fast_eval()</code> Medium Minimal checks Production with Numba <code>vectorized_eval()</code> Fastest Full validation Default choice <code>vectorized_eval_multi()</code> Fastest (multi) Full validation Price + Greeks at same point"},{"location":"user-guide/usage/#vectorized_eval-recommended","title":"<code>vectorized_eval()</code> \u2014 Recommended","text":"<p>Uses BLAS matrix-vector products. For 5D with 11 nodes, replaces 16,105 Python loop iterations with 5 BLAS calls:</p> <pre><code>price = cheb.vectorized_eval([100, 100, 1.0, 0.25, 0.05], [0, 0, 0, 0, 0])\n</code></pre>"},{"location":"user-guide/usage/#vectorized_eval_multi-best-for-multiple-derivatives","title":"<code>vectorized_eval_multi()</code> \u2014 Best for multiple derivatives","text":"<p>Pre-computes normalized barycentric weights once, reuses across all derivative orders:</p> <pre><code>results = cheb.vectorized_eval_multi(\n    [100, 100, 1.0, 0.25, 0.05],\n    [\n        [0, 0, 0, 0, 0],  # price\n        [1, 0, 0, 0, 0],  # delta (dV/dS)\n        [2, 0, 0, 0, 0],  # gamma (d\u00b2V/dS\u00b2)\n        [0, 0, 0, 1, 0],  # vega  (dV/d\u03c3)\n        [0, 0, 0, 0, 1],  # rho   (dV/dr)\n    ],\n)\nprice, delta, gamma, vega, rho = results\n</code></pre>"},{"location":"user-guide/usage/#batch-evaluation","title":"Batch Evaluation","text":"<p>For evaluating at many points:</p> <pre><code>import numpy as np\n\npoints = np.array([\n    [100, 100, 1.0, 0.25, 0.05],\n    [110, 100, 1.0, 0.25, 0.05],\n    [90, 100, 1.0, 0.25, 0.05],\n])\nprices = cheb.vectorized_eval_batch(points, [0, 0, 0, 0, 0])\n</code></pre>"},{"location":"user-guide/usage/#function-signature","title":"Function Signature","text":"<p>The function passed to <code>ChebyshevApproximation</code> must accept:</p> <ul> <li><code>point</code> \u2014 a list of floats (one per dimension)</li> <li><code>data</code> \u2014 arbitrary additional data (use <code>None</code> if not needed)</li> </ul> <pre><code>def my_func(point, data):\n    x, y, z = point\n    return x**2 + y * z\n</code></pre>"}]}